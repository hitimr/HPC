18.01. Hab  gestern versucht die doublequeue zu implementieren.

leider musste ich am ende so viel vom referenz code übernehmen, dass ich zweifle, dass das durchgehen wird. meine eigene variante zu kreieren hab ich leider nocht nicht geschafft.
dafür weiß ich jetzt wesentlich mehr über die aml und ich glaube, dass aml doch recht nützlich sein könnte.







15.01.2021: Hab ein neues Makefile erstellt weil das von graph500 furchtbar ist... Das neue ist jetzt auch im root folder (das alte nach wievor in ./src)
Files für die referenz implementierung und sssp hab ich auch rausgeworfen
Der cpp Code ist jetzt in bfs.cpp. Ich hab testweise eine Master-Slave kommunikation erstellt. Alle erstellten artefakte sind in ./build.

Zum starten im root folder folgende Befehle ausführen:

make
make run

Zum aufräumen:
make clean

Debuggen mit VS Code sollte jetzt auch mit cpp funktionieren. Allerdings läuft dabei nur die Master-Instanz

LG Mario







Ich habs jetzt nicht auf einem anderen PC getestet aber kompilieren sollte mit foglenden Befehlen gehen:

    cd src
    make

make führt dabei auch das program mit einer scale von 18 aus (kann im makefile geändert werden)
entfernen aller erstellten dateien geht mit "make clean"

Grundsätzlich solltest du auch mit VS Code debuggen können. Dafür den Repo-Ordner (HPC-main) mit VS Code öffnen und F5 drücken.
Die Parameter mit denen das Programm dann ausgeführt werden stehen in .vscode/launch.json -> args
Das debuggen von .c files geht immer aber in .cpp funktionieren die breakpoints manchmal einfach nicht. Ich konnte aber noch nicht herausfinden wieso..

Neuen c++ Code einfach in lib.cpp schreiben und neue Funktionen entsprechend in lib.h deklarieren.
Um auf globale Variablen aus den c-files zugreifen zu können musst du sie erst mit "extern [type] [name]" am anfang von lib.cpp deklarieren.
Das einbiden von graph500 header files oder structs in cpp code ist momentan leider nicht möglich.
Falls du doch daten aus einem struct brauchst würde ich dir raten diese in bfs_custom.c -> void run_bfs() auf einen standard-datentyp zurückzuführen und dann als funktionsparameter zu übergeben.

LG Mario





Graph500-3.0.0

Compiling should be pretty straightforward as long as you have a valid MPI-3 library loaded in your PATH.
There is no more OpenMP,Sequential and XMT versions of benchmark.

On single node you can run MPI code with reasonable performance.

To build binaries change directory to src and execute make.
If you are lucky four binaries would be built, two of which are of interest:

graph500_reference_bfs runs BFS kernel (and skips weight generation)
graph500_reference_bfs_sssp runs both BFS and SSSP kernels

Both binaries require one integer parameter which is scale of the graph.
Validation can be deactivated by specifying SKIP_VALIDATION=1 as an environment variable.
bfs_sssp binary would skip BFS part if SKIP_BFS=1 is present in your environment.

If you want to store/read generated graph from/to file use environment variables TMPFILE=<filename> and also REUSEFILE=1 to keep the file.
It's advised to use bfs_sssp binary to generate graph files as it generates both files of edges and weights (filename.weights)
bfs binary would only use/write edges file. And once bfs_sssp cant open weights file it would generate both files even if edges files is present.

N.B:

Current settings assume you are using powers of 2: total number of cores and number of cores per node.
It's possible to have non-power of two of nodes if you comment macro defined in common.h SIZE_MUST_BE_POWER_OF_TWO.
Be aware normally that will drop your performance by more then 20%.

If you want to use non-power of two processes per node, you should add -DPROCS_PER_NODE_NOT_POWER_OF_TWO to CFLAGS in src/Makefile,
this one will enable SIZE_MUST_BE_POWER_OF_TWO automatically.
